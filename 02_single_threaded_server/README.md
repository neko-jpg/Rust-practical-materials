# Level 2: シングルスレッド Webサーバー

## 課題
Rustの標準ライブラリのみを使用して、HTTPリクエストを受け取り、簡単なレスポンスを返すWebサーバーを作成します。

## 実行方法
1. サーバーを起動します:
   ```bash
   cargo run
   ```
2. ブラウザで `http://127.0.0.1:7878` にアクセスします。

## 実装ステップ

1. `src/main.rs` の `TODO` を実装します。
2. TCPリスナー (`TcpListener`) を作成し、ポート7878で待機させます。
3. 接続 (`TcpStream`) が確立されたら、それを処理する関数 `handle_connection` を呼び出します。
4. `handle_connection` 内でリクエストデータを読み込みます。
5. リクエストライン（例: `GET / HTTP/1.1`）を解析し、適切なレスポンス（ステータスコード、ヘッダー、ボディ）を返します。
6. (発展) ルーティングを実装し、`/` なら `hello.html`、それ以外なら `404.html` を返すようにします。

## ヒント
- `std::net::TcpListener` の `bind` と `incoming` メソッドを使います。
- `std::io::prelude::*` をインポートすると `Read`, `Write` トレイトが使えます。
- リクエストの区切りは `

` ですが、簡易的には `BufReader` で行ごとに読むことができます。

## Advanced Challenges (発展課題)
Level 2をクリアしたら、以下の機能を追加して「ミニフレームワーク」化してください。

### 1. ルーターの自作
現在の `if` 文による分岐をやめ、`Router` 構造体を作成してください。
- パスとハンドラ関数（クロージャ）を登録できる仕組みを作る。
- 例: `router.get("/", handler_fn)`

### 2. リクエスト解析の堅牢化
- `Content-Length` ヘッダーを解析し、ボディを正確に読み取る処理を実装してください。
- 不正なリクエストが来てもサーバーがクラッシュしないようにしてください。

### 3. ログ出力
- リクエストメソッド、パス、ステータスコード、処理時間を標準出力に表示してください。
